<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Classes on Project Madurai School</title>
    <link>/books/javascript/classes/</link>
    <description>Recent content in Classes on Project Madurai School</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 14 Nov 2018 19:02:50 -0700</lastBuildDate><atom:link href="/books/javascript/classes/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Class basic syntax</title>
      <link>/books/javascript/classes/class-basic-syntax/</link>
      <pubDate>Wed, 14 Nov 2018 19:02:50 -0700</pubDate>
      
      <guid>/books/javascript/classes/class-basic-syntax/</guid>
      <description>Class basic syntax  In object-oriented programming, a class is an extensible program-code-template for creating objects, providing initial values for state (member variables) and implementations of behavior (member functions or
 In practice, we often need to create many objects of the same kind, like users, or goods or whatever.
As we already know from the chapter Constructor, operator &amp;ldquo;new&amp;rdquo;, new function can help with that.
But in the modern JavaScript, there’s a more advanced “class” construct, that introduces great new features which are useful for object-oriented programming.</description>
    </item>
    
    <item>
      <title>Class inheritance</title>
      <link>/books/javascript/classes/class-inheritance/</link>
      <pubDate>Wed, 14 Nov 2018 19:02:50 -0700</pubDate>
      
      <guid>/books/javascript/classes/class-inheritance/</guid>
      <description>Class inheritance Class inheritance is a way for one class to extend another class.
So we can create new functionality on top of the existing.
The “extends” keyword Let’s say we have class Animal: 1 class Animal { 2 constructor(name) { 3 this.speed = 0; 4 this.name = name; 5 } 6 run(speed) { 7 this.speed = speed; 8 alert(`${this.name}runs with speed ${this.speed}.`); 9 } 10 stop() { 11 this.speed = 0; 12 alert(`${this.</description>
    </item>
    
    <item>
      <title>Static properties and methods</title>
      <link>/books/javascript/classes/static-properties-methods/</link>
      <pubDate>Wed, 14 Nov 2018 19:02:50 -0700</pubDate>
      
      <guid>/books/javascript/classes/static-properties-methods/</guid>
      <description>Static properties and methods We can also assign a method to the class function itself, not to its &amp;quot;prototype&amp;quot;. Such methods are called static.
In a class, they are prepended by static keyword, like this:
class User { static staticMethod() { alert(this === User); } } User.staticMethod(); // true  That actually does the same as assigning it as a property directly:
class User { } User.staticMethod = function() { alert(this === User); }; User.</description>
    </item>
    
    <item>
      <title>Private and protected properties and methods</title>
      <link>/books/javascript/classes/private-protected-properties-methods/</link>
      <pubDate>Wed, 14 Nov 2018 19:02:50 -0700</pubDate>
      
      <guid>/books/javascript/classes/private-protected-properties-methods/</guid>
      <description>Private and protected properties and methods One of the most important principles of object oriented programming – delimiting internal interface from the external one.
That is “a must” practice in developing anything more complex than a “hello world” app.
To understand this, let’s break away from development and turn our eyes into the real world.
Usually, devices that we’re using are quite complex. But delimiting the internal interface from the external one allows to use them without problems.</description>
    </item>
    
    <item>
      <title>Extending built-in classes</title>
      <link>/books/javascript/classes/extend-natives/</link>
      <pubDate>Wed, 14 Nov 2018 19:02:50 -0700</pubDate>
      
      <guid>/books/javascript/classes/extend-natives/</guid>
      <description>Extending built-in classes Built-in classes like Array, Map and others are extendable also.
For instance, here PowerArray inherits from the native Array:
// add one more method to it (can do more)  class PowerArray extends Array { isEmpty() { return this.length === 0; } } let arr = new PowerArray(1, 2, 5, 10, 50); alert(arr.isEmpty()); // false  let filteredArr = arr.filter(item =&amp;gt; item &amp;gt;= 10); alert(filteredArr); // 10, 50  alert(filteredArr.</description>
    </item>
    
    <item>
      <title>Class checking: &#34;instanceof</title>
      <link>/books/javascript/classes/instanceof/</link>
      <pubDate>Wed, 14 Nov 2018 19:02:50 -0700</pubDate>
      
      <guid>/books/javascript/classes/instanceof/</guid>
      <description>Class checking: &amp;ldquo;instanceof&amp;rdquo; The instanceof operator allows to check whether an object belongs to a certain class. It also takes inheritance into account.
Such a check may be necessary in many cases. For example, it can be used for building a polymorphic function, the one that treats arguments differently depending on their type.
The instanceof operator The syntax is:
obj instanceof Class It returns true if obj belongs to the Class or a class inheriting from it.</description>
    </item>
    
    <item>
      <title>Mixins</title>
      <link>/books/javascript/classes/mixins/</link>
      <pubDate>Wed, 14 Nov 2018 19:02:50 -0700</pubDate>
      
      <guid>/books/javascript/classes/mixins/</guid>
      <description>Mixins In JavaScript we can only inherit from a single object. There can be only one [[Prototype]] for an object. And a class may extend only one other class.
But sometimes that feels limiting. For instance, we have a class StreetSweeper and a class Bicycle, and want to make their mix: a StreetSweepingBicycle.
Or we have a class User and a class EventEmitter that implements event generation, and we’d like to add the functionality of EventEmitter to User, so that our users can emit events.</description>
    </item>
    
  </channel>
</rss>
