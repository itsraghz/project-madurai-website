<!DOCTYPE html>
<html lang="en">

<head>


  <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <base href="/">
    <title>Project Madurai School</title>

    
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="/images/apple-touch-icon.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="/images/favicon-32x32.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="/images/favicon-16x16.png"
    />
    <link rel="manifest" href="/images/site.webmanifest" />

    
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />


    

    <link rel="stylesheet" href="/css/style.css"/>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css"
      integrity="sha256-h20CPZ0QyXlBuAw7A+KluUYx/3pK+c7lYEpqLTlxjYQ="
      crossorigin="anonymous"
    />



  


</head>

<body>
  <main class="container mt-5 w-100 h-100">
    <nav class="navbar navbar-expand-md navbar-light bg-white py-0 fixed-top">
  <div class="container-fluid border-bottom border-top-1 shadow-sm bg-body">
    <a class="navbar-brand lh-1" href="/">
      
      
        <span class="text-primary"><strong>Project Madurai</strong></span><br>
        <p class="text-muted text-end w-100 p-0 mb-0"><small class="dropdown-toggle">தமிழ்</small></p>
      </a>

      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarsExampleDefault"
      aria-controls="navbarsExampleDefault" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" id="navbarsExampleDefault">
      <ul class="navbar-nav me-auto mb-2 mb-lg-0">
        <li class="nav-item">
          <a class="nav-link active" href="/books/javascript">Javascript</a>
        </li>
        <li class="nav-item">
          <a class="nav-link active" href="/books/c">C</a>
        </li>
        <li class="nav-item">
          <a class="nav-link active" href="/practices/java">Java</a>
        </li>
        <li class="nav-item">
          <a class="nav-link active" href="/posts">Blog</a>
        </li>
      </ul>
      <form class="d-flex">
        <input class="form-control" type="search" placeholder="Search" aria-label="Search">
      </form>
      <ul class="navbar-nav secured">
        <li class="nav-item btn pe-0">
          <a class="nav-link" href="/chat"><i class="far fa-comment-dots fa-2x"></i></a>
        </li>
        <li class="nav-item pe-0 dropdown">
          
          <div class="btn-group bg-light">
            <a class="btn btn-toggle pe-0" data-bs-toggle="dropdown" aria-expanded="false">
              <div class="d-flex bd-highlight">
                <div class="w-100 bd-highlight text-end">
                  <h6 class="text-muted fw-bold">தமிழ்ச் சங்கம்</h6>
                  <small class="text-muted">திருவள்ளுவர் கழகம்</small>
               </div>
                <div class="flex-shrink-1 bd-highlight">
                  <img src="http://ssl.gstatic.com/accounts/ui/avatar_2x.png" class="img-circle img-thumbnail avatar"
                style="vertical-align: middle;border-radius: 50%; width: 3rem; margin-right: 10px;" alt="avatar">
                </div>
                
                
              </div>
            </a>
            <ul class="dropdown-menu" aria-labelledby="dropdown03">
              <li><a class="dropdown-item" href="javascript://">Profile</a></li>
              <li><a class="dropdown-item" href="/campuses/tamil-sangam">Campus</a></li>
              <li><a class="dropdown-item logout" href="javascript://">Logout</a></li>
            </ul>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
    <div class="row py-5 w-100 h-100">
       

  <nav class="navbar border-1 border-bottom">
  <div class="row w-100">
    <div class="col-4">
      <a href="/books/javascript/advanced-working-with-functions/settimeout-setinterval">Scheduling: setTimeout and setInterval</a>
    </div>
    <div class="col-4 mb-2 text-center">
      <a class="text-dark"
        href="/books/javascript/advanced-working-with-functions">Advanced Working with Functions</a>
    </div>
    <div class="col-4 d-flex justify-content-end align-items-center">
      <a href="/books/javascript/advanced-working-with-functions/bind">Function binding</a>
    </div>
  </div>
</nav>

<main id="content" class="pt-3"><h1 id="decorators-and-forwarding-callapply">Decorators and forwarding, call/apply</h1>
<p>JavaScript gives exceptional flexibility when dealing with functions. They can be passed around, used as objects, and now we&rsquo;ll see how to <em>forward</em> calls between them and <em>decorate</em> them.</p>
<h2 id="transparent-caching">Transparent caching</h2>
<p>Let&rsquo;s say we have a function <code>slow(x)</code> which is CPU-heavy, but its results are stable. In other words, for the same <code>x</code> it always returns the same result.</p>
<p>If the function is called often, we may want to cache (remember) the results to avoid spending extra-time on recalculations.</p>
<p>But instead of adding that functionality into <code>slow()</code> we&rsquo;ll create a wrapper function, that adds caching. As we&rsquo;ll see, there are many benefits of doing so.</p>
<p>Here&rsquo;s the code, and explanations follow:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">slow</span>(<span style="color:#a6e22e">x</span>) {
  <span style="color:#75715e">// there can be a heavy CPU-intensive job here
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">alert</span>(<span style="color:#e6db74">`Called with </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">x</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span>;
}

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">cachingDecorator</span>(<span style="color:#a6e22e">func</span>) {
  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">cache</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Map</span>();

  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">x</span>) {
    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">cache</span>.<span style="color:#a6e22e">has</span>(<span style="color:#a6e22e">x</span>)) {    <span style="color:#75715e">// if there&#39;s such key in cache
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">cache</span>.<span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">x</span>); <span style="color:#75715e">// read the result from it
</span><span style="color:#75715e"></span>    }

    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">func</span>(<span style="color:#a6e22e">x</span>);  <span style="color:#75715e">// otherwise call func
</span><span style="color:#75715e"></span>
    <span style="color:#a6e22e">cache</span>.<span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">result</span>);  <span style="color:#75715e">// and cache (remember) the result
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>;
  };
}

<span style="color:#a6e22e">slow</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">cachingDecorator</span>(<span style="color:#a6e22e">slow</span>);

<span style="color:#a6e22e">alert</span>( <span style="color:#a6e22e">slow</span>(<span style="color:#ae81ff">1</span>) ); <span style="color:#75715e">// slow(1) is cached and the result returned
</span><span style="color:#75715e"></span><span style="color:#a6e22e">alert</span>( <span style="color:#e6db74">&#34;Again: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">slow</span>(<span style="color:#ae81ff">1</span>) ); <span style="color:#75715e">// slow(1) result returned from cache
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">alert</span>( <span style="color:#a6e22e">slow</span>(<span style="color:#ae81ff">2</span>) ); <span style="color:#75715e">// slow(2) is cached and the result returned
</span><span style="color:#75715e"></span><span style="color:#a6e22e">alert</span>( <span style="color:#e6db74">&#34;Again: &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">slow</span>(<span style="color:#ae81ff">2</span>) ); <span style="color:#75715e">// slow(2) result returned from cache
</span></code></pre></div><p>In the code above <code>cachingDecorator</code> is a <em>decorator</em>: a special function that takes another function and alters its behavior.</p>
<p>The idea is that we can call <code>cachingDecorator</code> for any function, and it will return the caching wrapper. That&rsquo;s great, because we can have many functions that could use such a feature, and all we need to do is to apply <code>cachingDecorator</code> to them.</p>
<p>By separating caching from the main function code we also keep the main code simpler.</p>
<p>The result of <code>cachingDecorator(func)</code> is a &ldquo;wrapper&rdquo;: <code>function(x)</code> that &ldquo;wraps&rdquo; the call of <code>func(x)</code> into caching logic:</p>
<p><img src="https://raw.githubusercontent.com/javascript-tutorial/en.javascript.info/cf33b67042d72df14e41f6688695ef833467f7f7/1-js/06-advanced-functions/09-call-apply-decorators/decorator-makecaching-wrapper.svg" alt=""></p>
<p>From an outside code, the wrapped <code>slow</code> function still does the same. It just got a caching aspect added to its behavior.</p>
<p>To summarize, there are several benefits of using a separate <code>cachingDecorator</code> instead of altering the code of <code>slow</code> itself:</p>
<ul>
<li>The <code>cachingDecorator</code> is reusable. We can apply it to another function.</li>
<li>The caching logic is separate, it did not increase the complexity of <code>slow</code> itself (if there was any).</li>
<li>We can combine multiple decorators if needed (other decorators will follow).</li>
</ul>
<h2 id="using-funccall-for-the-context">Using &ldquo;func.call&rdquo; for the context</h2>
<p>The caching decorator mentioned above is not suited to work with object methods.</p>
<p>For instance, in the code below <code>worker.slow()</code> stops working after the decoration:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// we&#39;ll make worker.slow caching
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">worker</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">someMethod</span>() {
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
  },

  <span style="color:#a6e22e">slow</span>(<span style="color:#a6e22e">x</span>) {
    <span style="color:#75715e">// scary CPU-heavy task here  
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">alert</span>(<span style="color:#e6db74">&#34;Called with &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">x</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">someMethod</span>(); <span style="color:#75715e">// (*)
</span><span style="color:#75715e"></span>  }
};

<span style="color:#75715e">// same code as before
</span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">cachingDecorator</span>(<span style="color:#a6e22e">func</span>) {
  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">cache</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Map</span>();
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">x</span>) {
    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">cache</span>.<span style="color:#a6e22e">has</span>(<span style="color:#a6e22e">x</span>)) {
      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">cache</span>.<span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">x</span>);
    }
<span style="color:#f92672">*!*</span>
    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">func</span>(<span style="color:#a6e22e">x</span>); <span style="color:#75715e">// (**)
</span><span style="color:#75715e"></span><span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">/!*</span>
    <span style="color:#a6e22e">cache</span>.<span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">result</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>;
  };
}

<span style="color:#a6e22e">alert</span>( <span style="color:#a6e22e">worker</span>.<span style="color:#a6e22e">slow</span>(<span style="color:#ae81ff">1</span>) ); <span style="color:#75715e">// the original method works
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">worker</span>.<span style="color:#a6e22e">slow</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">cachingDecorator</span>(<span style="color:#a6e22e">worker</span>.<span style="color:#a6e22e">slow</span>); <span style="color:#75715e">// now make it caching
</span><span style="color:#75715e"></span>
<span style="color:#f92672">*!*</span>
<span style="color:#a6e22e">alert</span>( <span style="color:#a6e22e">worker</span>.<span style="color:#a6e22e">slow</span>(<span style="color:#ae81ff">2</span>) ); <span style="color:#75715e">// Whoops! Error: Cannot read property &#39;someMethod&#39; of undefined
</span><span style="color:#75715e"></span><span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">/!*</span>
</code></pre></div><p>The error occurs in the line <code>(*)</code> that tries to access <code>this.someMethod</code> and fails. Can you see why?</p>
<p>The reason is that the wrapper calls the original function as <code>func(x)</code> in the line <code>(**)</code>. And, when called like that, the function gets <code>this = undefined</code>.</p>
<p>We would observe a similar symptom if we tried to run:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">func</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">worker</span>.<span style="color:#a6e22e">slow</span>;
<span style="color:#a6e22e">func</span>(<span style="color:#ae81ff">2</span>);
</code></pre></div><p>So, the wrapper passes the call to the original method, but without the context <code>this</code>. Hence the error.</p>
<p>Let&rsquo;s fix it.</p>
<p>There&rsquo;s a special built-in function method <a href="mdn:js/Function/call">func.call(context, &hellip;args)</a> that allows to call a function explicitly setting <code>this</code>.</p>
<p>The syntax is:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">func</span>.<span style="color:#a6e22e">call</span>(<span style="color:#a6e22e">context</span>, <span style="color:#a6e22e">arg1</span>, <span style="color:#a6e22e">arg2</span>, ...)
</code></pre></div><p>It runs <code>func</code> providing the first argument as <code>this</code>, and the next as the arguments.</p>
<p>To put it simply, these two calls do almost the same:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">func</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>);
<span style="color:#a6e22e">func</span>.<span style="color:#a6e22e">call</span>(<span style="color:#a6e22e">obj</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>)
</code></pre></div><p>They both call <code>func</code> with arguments <code>1</code>, <code>2</code> and <code>3</code>. The only difference is that <code>func.call</code> also sets <code>this</code> to <code>obj</code>.</p>
<p>As an example, in the code below we call <code>sayHi</code> in the context of different objects: <code>sayHi.call(user)</code> runs <code>sayHi</code> providing <code>this=user</code>, and the next line sets <code>this=admin</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">sayHi</span>() {
  <span style="color:#a6e22e">alert</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span>);
}

<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">user</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;John&#34;</span> };
<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">admin</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Admin&#34;</span> };

<span style="color:#75715e">// use call to pass different objects as &#34;this&#34;
</span><span style="color:#75715e"></span><span style="color:#a6e22e">sayHi</span>.<span style="color:#a6e22e">call</span>( <span style="color:#a6e22e">user</span> ); <span style="color:#75715e">// John
</span><span style="color:#75715e"></span><span style="color:#a6e22e">sayHi</span>.<span style="color:#a6e22e">call</span>( <span style="color:#a6e22e">admin</span> ); <span style="color:#75715e">// Admin
</span></code></pre></div><p>And here we use <code>call</code> to call <code>say</code> with the given context and phrase:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">say</span>(<span style="color:#a6e22e">phrase</span>) {
  <span style="color:#a6e22e">alert</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;: &#39;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">phrase</span>);
}

<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">user</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;John&#34;</span> };

<span style="color:#75715e">// user becomes this, and &#34;Hello&#34; becomes the first argument
</span><span style="color:#75715e"></span><span style="color:#a6e22e">say</span>.<span style="color:#a6e22e">call</span>( <span style="color:#a6e22e">user</span>, <span style="color:#e6db74">&#34;Hello&#34;</span> ); <span style="color:#75715e">// John: Hello
</span></code></pre></div><p>In our case, we can use <code>call</code> in the wrapper to pass the context to the original function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">worker</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">someMethod</span>() {
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
  },

  <span style="color:#a6e22e">slow</span>(<span style="color:#a6e22e">x</span>) {
    <span style="color:#a6e22e">alert</span>(<span style="color:#e6db74">&#34;Called with &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">x</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">someMethod</span>(); <span style="color:#75715e">// (*)
</span><span style="color:#75715e"></span>  }
};

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">cachingDecorator</span>(<span style="color:#a6e22e">func</span>) {
  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">cache</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Map</span>();
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">x</span>) {
    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">cache</span>.<span style="color:#a6e22e">has</span>(<span style="color:#a6e22e">x</span>)) {
      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">cache</span>.<span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">x</span>);
    }
<span style="color:#f92672">*!*</span>
    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">func</span>.<span style="color:#a6e22e">call</span>(<span style="color:#66d9ef">this</span>, <span style="color:#a6e22e">x</span>); <span style="color:#75715e">// &#34;this&#34; is passed correctly now
</span><span style="color:#75715e"></span><span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">/!*</span>
    <span style="color:#a6e22e">cache</span>.<span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">result</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>;
  };
}

<span style="color:#a6e22e">worker</span>.<span style="color:#a6e22e">slow</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">cachingDecorator</span>(<span style="color:#a6e22e">worker</span>.<span style="color:#a6e22e">slow</span>); <span style="color:#75715e">// now make it caching
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">alert</span>( <span style="color:#a6e22e">worker</span>.<span style="color:#a6e22e">slow</span>(<span style="color:#ae81ff">2</span>) ); <span style="color:#75715e">// works
</span><span style="color:#75715e"></span><span style="color:#a6e22e">alert</span>( <span style="color:#a6e22e">worker</span>.<span style="color:#a6e22e">slow</span>(<span style="color:#ae81ff">2</span>) ); <span style="color:#75715e">// works, doesn&#39;t call the original (cached)
</span></code></pre></div><p>Now everything is fine.</p>
<p>To make it all clear, let&rsquo;s see more deeply how <code>this</code> is passed along:</p>
<ol>
<li>After the decoration <code>worker.slow</code> is now the wrapper <code>function (x) { ... }</code>.</li>
<li>So when <code>worker.slow(2)</code> is executed, the wrapper gets <code>2</code> as an argument and <code>this=worker</code> (it&rsquo;s the object before dot).</li>
<li>Inside the wrapper, assuming the result is not yet cached, <code>func.call(this, x)</code> passes the current <code>this</code> (<code>=worker</code>) and the current argument (<code>=2</code>) to the original method.</li>
</ol>
<h2 id="going-multi-argument">Going multi-argument</h2>
<p>Now let&rsquo;s make <code>cachingDecorator</code> even more universal. Till now it was working only with single-argument functions.</p>
<p>Now how to cache the multi-argument <code>worker.slow</code> method?</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">worker</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">slow</span>(<span style="color:#a6e22e">min</span>, <span style="color:#a6e22e">max</span>) {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">min</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">max</span>; <span style="color:#75715e">// scary CPU-hogger is assumed
</span><span style="color:#75715e"></span>  }
};

<span style="color:#75715e">// should remember same-argument calls
</span><span style="color:#75715e"></span><span style="color:#a6e22e">worker</span>.<span style="color:#a6e22e">slow</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">cachingDecorator</span>(<span style="color:#a6e22e">worker</span>.<span style="color:#a6e22e">slow</span>);
</code></pre></div><p>Previously, for a single argument <code>x</code> we could just <code>cache.set(x, result)</code> to save the result and <code>cache.get(x)</code> to retrieve it. But now we need to remember the result for a <em>combination of arguments</em> <code>(min,max)</code>. The native <code>Map</code> takes single value only as the key.</p>
<p>There are many solutions possible:</p>
<ol>
<li>Implement a new (or use a third-party) map-like data structure that is more versatile and allows multi-keys.</li>
<li>Use nested maps: <code>cache.set(min)</code> will be a <code>Map</code> that stores the pair <code>(max, result)</code>. So we can get <code>result</code> as <code>cache.get(min).get(max)</code>.</li>
<li>Join two values into one. In our particular case we can just use a string <code>&quot;min,max&quot;</code> as the <code>Map</code> key. For flexibility, we can allow to provide a <em>hashing function</em> for the decorator, that knows how to make one value from many.</li>
</ol>
<p>For many practical applications, the 3rd variant is good enough, so we&rsquo;ll stick to it.</p>
<p>Also we need to pass not just <code>x</code>, but all arguments in <code>func.call</code>. Let&rsquo;s recall that in a <code>function()</code> we can get a pseudo-array of its arguments as <code>arguments</code>, so <code>func.call(this, x)</code> should be replaced with <code>func.call(this, ...arguments)</code>.</p>
<p>Here&rsquo;s a more powerful <code>cachingDecorator</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">worker</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">slow</span>(<span style="color:#a6e22e">min</span>, <span style="color:#a6e22e">max</span>) {
    <span style="color:#a6e22e">alert</span>(<span style="color:#e6db74">`Called with </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">min</span><span style="color:#e6db74">}</span><span style="color:#e6db74">,</span><span style="color:#e6db74">${</span><span style="color:#a6e22e">max</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">min</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">max</span>;
  }
};

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">cachingDecorator</span>(<span style="color:#a6e22e">func</span>, <span style="color:#a6e22e">hash</span>) {
  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">cache</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Map</span>();
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">function</span>() {
<span style="color:#f92672">*!*</span>
    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">key</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">hash</span>(<span style="color:#a6e22e">arguments</span>); <span style="color:#75715e">// (*)
</span><span style="color:#75715e"></span><span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">/!*</span>
    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">cache</span>.<span style="color:#a6e22e">has</span>(<span style="color:#a6e22e">key</span>)) {
      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">cache</span>.<span style="color:#a6e22e">get</span>(<span style="color:#a6e22e">key</span>);
    }

<span style="color:#f92672">*!*</span>
    <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">func</span>.<span style="color:#a6e22e">call</span>(<span style="color:#66d9ef">this</span>, ...<span style="color:#a6e22e">arguments</span>); <span style="color:#75715e">// (**)
</span><span style="color:#75715e"></span><span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">/!*</span>

    <span style="color:#a6e22e">cache</span>.<span style="color:#a6e22e">set</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">result</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>;
  };
}

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">hash</span>(<span style="color:#a6e22e">args</span>) {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">args</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;,&#39;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">args</span>[<span style="color:#ae81ff">1</span>];
}

<span style="color:#a6e22e">worker</span>.<span style="color:#a6e22e">slow</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">cachingDecorator</span>(<span style="color:#a6e22e">worker</span>.<span style="color:#a6e22e">slow</span>, <span style="color:#a6e22e">hash</span>);

<span style="color:#a6e22e">alert</span>( <span style="color:#a6e22e">worker</span>.<span style="color:#a6e22e">slow</span>(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>) ); <span style="color:#75715e">// works
</span><span style="color:#75715e"></span><span style="color:#a6e22e">alert</span>( <span style="color:#e6db74">&#34;Again &#34;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">worker</span>.<span style="color:#a6e22e">slow</span>(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>) ); <span style="color:#75715e">// same (cached)
</span></code></pre></div><p>Now it works with any number of arguments (though the hash function would also need to be adjusted to allow any number of arguments. An interesting way to handle this will be covered below).</p>
<p>There are two changes:</p>
<ul>
<li>In the line <code>(*)</code> it calls <code>hash</code> to create a single key from <code>arguments</code>. Here we use a simple &ldquo;joining&rdquo; function that turns arguments <code>(3, 5)</code> into the key <code>&quot;3,5&quot;</code>. More complex cases may require other hashing functions.</li>
<li>Then <code>(**)</code> uses <code>func.call(this, ...arguments)</code> to pass both the context and all arguments the wrapper got (not just the first one) to the original function.</li>
</ul>
<h2 id="funcapply">func.apply</h2>
<p>Instead of <code>func.call(this, ...arguments)</code> we could use <code>func.apply(this, arguments)</code>.</p>
<p>The syntax of built-in method <a href="mdn:js/Function/apply">func.apply</a> is:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">func</span>.<span style="color:#a6e22e">apply</span>(<span style="color:#a6e22e">context</span>, <span style="color:#a6e22e">args</span>)
</code></pre></div><p>It runs the <code>func</code> setting <code>this=context</code> and using an array-like object <code>args</code> as the list of arguments.</p>
<p>The only syntax difference between <code>call</code> and <code>apply</code> is that <code>call</code> expects a list of arguments, while <code>apply</code> takes an array-like object with them.</p>
<p>So these two calls are almost equivalent:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">func</span>.<span style="color:#a6e22e">call</span>(<span style="color:#a6e22e">context</span>, ...<span style="color:#a6e22e">args</span>);
<span style="color:#a6e22e">func</span>.<span style="color:#a6e22e">apply</span>(<span style="color:#a6e22e">context</span>, <span style="color:#a6e22e">args</span>);
</code></pre></div><p>They perform the same call of <code>func</code> with given context and arguments.</p>
<p>There&rsquo;s only a subtle difference regarding <code>args</code>:</p>
<ul>
<li>The spread syntax <code>...</code> allows to pass <em>iterable</em> <code>args</code> as the list to <code>call</code>.</li>
<li>The <code>apply</code> accepts only <em>array-like</em> <code>args</code>.</li>
</ul>
<p>&hellip;And for objects that are both iterable and array-like, such as a real array, we can use any of them, but <code>apply</code> will probably be faster, because most JavaScript engines internally optimize it better.</p>
<p>Passing all arguments along with the context to another function is called <em>call forwarding</em>.</p>
<p>That&rsquo;s the simplest form of it:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">wrapper</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>() {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">func</span>.<span style="color:#a6e22e">apply</span>(<span style="color:#66d9ef">this</span>, <span style="color:#a6e22e">arguments</span>);
};
</code></pre></div><p>When an external code calls such <code>wrapper</code>, it is indistinguishable from the call of the original function <code>func</code>.</p>
<h2 id="borrowing-a-method-method-borrowing">Borrowing a method [#method-borrowing]</h2>
<p>Now let&rsquo;s make one more minor improvement in the hashing function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">hash</span>(<span style="color:#a6e22e">args</span>) {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">args</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;,&#39;</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">args</span>[<span style="color:#ae81ff">1</span>];
}
</code></pre></div><p>As of now, it works only on two arguments. It would be better if it could glue any number of <code>args</code>.</p>
<p>The natural solution would be to use <a href="mdn:js/Array/join">arr.join</a> method:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">hash</span>(<span style="color:#a6e22e">args</span>) {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">args</span>.<span style="color:#a6e22e">join</span>();
}
</code></pre></div><p>&hellip;Unfortunately, that won&rsquo;t work. Because we are calling <code>hash(arguments)</code>, and <code>arguments</code> object is both iterable and array-like, but not a real array.</p>
<p>So calling <code>join</code> on it would fail, as we can see below:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">hash</span>() {
<span style="color:#f92672">*!*</span>
  <span style="color:#a6e22e">alert</span>( <span style="color:#a6e22e">arguments</span>.<span style="color:#a6e22e">join</span>() ); <span style="color:#75715e">// Error: arguments.join is not a function
</span><span style="color:#75715e"></span><span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">/!*</span>
}

<span style="color:#a6e22e">hash</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>);
</code></pre></div><p>Still, there&rsquo;s an easy way to use array join:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">hash</span>() {
<span style="color:#f92672">*!*</span>
  <span style="color:#a6e22e">alert</span>( [].<span style="color:#a6e22e">join</span>.<span style="color:#a6e22e">call</span>(<span style="color:#a6e22e">arguments</span>) ); <span style="color:#75715e">// 1,2
</span><span style="color:#75715e"></span><span style="color:#f92672">*</span><span style="color:#960050;background-color:#1e0010">/!*</span>
}

<span style="color:#a6e22e">hash</span>(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>);
</code></pre></div><p>The trick is called <em>method borrowing</em>.</p>
<p>We take (borrow) a join method from a regular array (<code>[].join</code>) and use <code>[].join.call</code> to run it in the context of <code>arguments</code>.</p>
<p>Why does it work?</p>
<p>That&rsquo;s because the internal algorithm of the native method <code>arr.join(glue)</code> is very simple.</p>
<p>Taken from the specification almost &ldquo;as-is&rdquo;:</p>
<ol>
<li>Let <code>glue</code> be the first argument or, if no arguments, then a comma <code>&quot;,&quot;</code>.</li>
<li>Let <code>result</code> be an empty string.</li>
<li>Append <code>this[0]</code> to <code>result</code>.</li>
<li>Append <code>glue</code> and <code>this[1]</code>.</li>
<li>Append <code>glue</code> and <code>this[2]</code>.</li>
<li>&hellip;Do so until <code>this.length</code> items are glued.</li>
<li>Return <code>result</code>.</li>
</ol>
<p>So, technically it takes <code>this</code> and joins <code>this[0]</code>, <code>this[1]</code> &hellip;etc together. It&rsquo;s intentionally written in a way that allows any array-like <code>this</code> (not a coincidence, many methods follow this practice). That&rsquo;s why it also works with <code>this=arguments</code>.</p>
<h2 id="decorators-and-function-properties">Decorators and function properties</h2>
<p>It is generally safe to replace a function or a method with a decorated one, except for one little thing. If the original function had properties on it, like <code>func.calledCount</code> or whatever, then the decorated one will not provide them. Because that is a wrapper. So one needs to be careful if one uses them.</p>
<p>E.g. in the example above if <code>slow</code> function had any properties on it, then <code>cachingDecorator(slow)</code> is a wrapper without them.</p>
<p>Some decorators may provide their own properties. E.g. a decorator may count how many times a function was invoked and how much time it took, and expose this information via wrapper properties.</p>
<p>There exists a way to create decorators that keep access to function properties, but this requires using a special <code>Proxy</code> object to wrap a function. We&rsquo;ll discuss it later in the article <a href="info:proxy#proxy-apply">info:proxy#proxy-apply</a>.</p>
<h2 id="summary">Summary</h2>
<p><em>Decorator</em> is a wrapper around a function that alters its behavior. The main job is still carried out by the function.</p>
<p>Decorators can be seen as &ldquo;features&rdquo; or &ldquo;aspects&rdquo; that can be added to a function. We can add one or add many. And all this without changing its code!</p>
<p>To implement <code>cachingDecorator</code>, we studied methods:</p>
<ul>
<li><a href="mdn:js/Function/call">func.call(context, arg1, arg2&hellip;)</a> &ndash; calls <code>func</code> with given context and arguments.</li>
<li><a href="mdn:js/Function/apply">func.apply(context, args)</a> &ndash; calls <code>func</code> passing <code>context</code> as <code>this</code> and array-like <code>args</code> into a list of arguments.</li>
</ul>
<p>The generic <em>call forwarding</em> is usually done with <code>apply</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">wrapper</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>() {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">original</span>.<span style="color:#a6e22e">apply</span>(<span style="color:#66d9ef">this</span>, <span style="color:#a6e22e">arguments</span>);
};
</code></pre></div><p>We also saw an example of <em>method borrowing</em> when we take a method from an object and <code>call</code> it in the context of another object. It is quite common to take array methods and apply them to <code>arguments</code>. The alternative is to use rest parameters object that is a real array.</p>
<p>There are many decorators there in the wild. Check how well you got them by solving the tasks of this chapter.</p>
</main>


<div class="modal fade" id="noteModel" tabindex="-1" aria-labelledby="noteModelLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="noteModelLabel">Note</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="mb-3">
          <textarea class="form-control" id="noteText" rows="3"></textarea>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
        <button type="button" class="btn btn-primary">Save changes</button>
      </div>
    </div>
  </div>
</div>


    </div>
    
  </main>
  
  



<div class="modal fade" id="exampleModal" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="exampleModalLabel">Confimation</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          Are you sure you want to delete ?
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">No</button>
          <button type="button" class="btn btn-primary">Yes</button>
        </div>
      </div>
    </div>
  </div>

<div aria-live="polite" aria-atomic="true">
  <div class="toast-container position-absolute top-0 start-0 p-5 mt-5" id="toast-container">
    
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js" integrity="sha384-IQsoLXl5PILFhosVNubq5LC7Qb9DXgDA9i+tQ8Zj3iwWAwPtgFTxbJ8NT4GN1R8p" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/js/bootstrap.min.js" integrity="sha384-Atwg2Pkwv9vp0ygtn1JAojH0nYbwNJLPhwyoVbhoPwBhjQPR5VtM2+xf0Uwh9KtT" crossorigin="anonymous"></script>
<script type="text/javascript" src="/js/app.js"></script>



  
  
  

<script type="text/javascript" src="/js/chapter.js"></script>


  
</body>

</html>