<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Modules on Project Madurai School</title>
    <link>/books/javascript/modules/</link>
    <description>Recent content in Modules on Project Madurai School</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 14 Nov 2018 19:02:50 -0700</lastBuildDate><atom:link href="/books/javascript/modules/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Modules, introduction</title>
      <link>/books/javascript/modules/modules-intro/</link>
      <pubDate>Wed, 14 Nov 2018 19:02:50 -0700</pubDate>
      
      <guid>/books/javascript/modules/modules-intro/</guid>
      <description>Modules, introduction As our application grows bigger, we want to split it into multiple files, so called &amp;ldquo;modules&amp;rdquo;. A module may contain a class or a library of functions for a specific purpose.
For a long time, JavaScript existed without a language-level module syntax. That wasn&amp;rsquo;t a problem, because initially scripts were small and simple, so there was no need.
But eventually scripts became more and more complex, so the community invented a variety of ways to organize code into modules, special libraries to load modules on demand.</description>
    </item>
    
    <item>
      <title>Export and Import</title>
      <link>/books/javascript/modules/export-import/</link>
      <pubDate>Wed, 14 Nov 2018 19:02:50 -0700</pubDate>
      
      <guid>/books/javascript/modules/export-import/</guid>
      <description>Export and Import Export and import directives have several syntax variants.
In the previous article we saw a simple use, now let&amp;rsquo;s explore more examples.
Export before declarations We can label any declaration as exported by placing export before it, be it a variable, function or a class.
For instance, here all exports are valid:
// export an array *!*export*/!* let months = [&amp;#39;Jan&amp;#39;, &amp;#39;Feb&amp;#39;, &amp;#39;Mar&amp;#39;,&amp;#39;Apr&amp;#39;, &amp;#39;Aug&amp;#39;, &amp;#39;Sep&amp;#39;, &amp;#39;Oct&amp;#39;, &amp;#39;Nov&amp;#39;, &amp;#39;Dec&amp;#39;]; // export a constant *!</description>
    </item>
    
    <item>
      <title>Dynamic imports</title>
      <link>/books/javascript/modules/modules-dynamic-import/</link>
      <pubDate>Wed, 14 Nov 2018 19:02:50 -0700</pubDate>
      
      <guid>/books/javascript/modules/modules-dynamic-import/</guid>
      <description>Dynamic imports Export and import statements that we covered in previous chapters are called &amp;ldquo;static&amp;rdquo;. The syntax is very simple and strict.
First, we can&amp;rsquo;t dynamically generate any parameters of import.
The module path must be a primitive string, can&amp;rsquo;t be a function call. This won&amp;rsquo;t work:
import ... from *!*getModuleName()*/!*; // Error, only from &amp;#34;string&amp;#34; is allowed Second, we can&amp;rsquo;t import conditionally or at run-time:
if(...) { import ...; // Error, not allowed!</description>
    </item>
    
  </channel>
</rss>
